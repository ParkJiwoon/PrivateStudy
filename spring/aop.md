# Spring AOP

# Spring AOP 실무 주의사항

프록시 방식의 Spring AOP 를 실무에서 사용할 때의 주의사항 두가지를 알아보고 해결방법을 알아봅니다.

<br>

## 1. 프록시와 내부호출

스프링은 프록시 방식의 AOP 사용합니다.

따라서 AOP 를 적용하려면 대상 객체 (Target) 를 호출해야 합니다.

하지만 **대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 직접 호출하는 문제**가 발생합니다.

<br>

### 원인

내부에서 호출하면 현재 자신의 인스턴스로 호출하게 됩니다.

따라서 프록시를 거쳐서 호출하는게 아닌 Target 객체의 메서드를 직접 호출하는 거라서 AOP 가 적용되지 않습니다.

<br>

### 프록시 방식의 AOP 한계

스프링은 프록시 방식의 AOP 를 사용하기 때문에 내부 호출에 프록시를 적용할 수 없습니다.

실제 코드에 직접 적용하는 `AspectJ` 방식을 사용하면 **컴파일 시점 또는 클래스 로드 시점에 직접 코드를 끼워넣는 방식**이라서 외부에서 호출하던 내부에서 호출하던 문제가 발생하지 않습니다.

하지만 로드 타임 위빙을 위해 추가 설정을 하거나 JVM 옵션을 주어야 하는 등 불편한 점이 많습니다.

프록시 방식일 때 내부 메서드 호출 문제를 해결하는 방법을 알아봅니다.

<br>

### 해결방법

1. 자기자신을 주입받아서 호출
  - 내부에서 바로 호출하면 프록시를 타지 못하므로 자기 자신의 Bean 을 주입 받아서 외부호출처럼 변경
  - 생성자 주입을 쓰면 순환참조가 발생하기 때문에 Setter 또는 Field 주입을 해야함
  - **Spring Boot 2.6 부터는 순환 참조를 기본으로 막아놨기 때문에 사용 불가능**
2. 지연 조회
  - 셀프 주입과 비슷하지만 메서드 호출 시점에 빈을 꺼낸다는게 차이점
  - 순환 참조가 발생하지 않음
3. 구조 변경
  - 스프링에서 가장 권장하는 방법
  - 그냥 별도의 컴포넌트를 만들어서 호출, 즉 내부 메서드 호출을 물리적으로 제거

<br>

## 2. 타입 캐스팅

JDK 동적 프록시와 CGLIB 는 프록시 생성 시 차이점이 있습니다.

JDK 동적 프록시는 인터페이스 기반으로 생성하고 CGLIB 는 구체 클래스 기반으로 생성합니다.

인터페이스가 없고 구체 클래스만 존재하는 경우에는 CGLIB 를 사용할 수밖에 없지만, 인터페이스가 존재하는 경우에는 옵션으로 둘 중 어떤걸 사용할지 선택할 수 있습니다.

`ProxyFactory` 의 `proxyTargetClass` 옵션에 따라 생성 방법이 고정됩니다.

<br>

# Reference

- 스프링 핵심 원리 - 고급편
