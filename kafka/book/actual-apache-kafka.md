# 실전 아파치 카프카

# 1장 카프카 개요

## 1.1. 카프카의 장점

- 높은 처리량
  - HTTP 기반으로 전달되는 이벤트도 카프카로 처리되는 응답 시간은 한자리수 ms
- 순서 보장
  - 엔티티 간의 유효성 검사나 동시 수정 같은 무수한 복잡성 제거 가능
- 적어도 한번 (at least once) 전송 방식
  - 멱등성 (동일한 작업을 여러 번 수행하더라도 결과가 달라지지 않는 것) 이 보장되기 때문에 이벤트가 중복 발생해도 문제 없음
  - 이벤트 중복에서 자유롭기 때문에 프로듀서가 부담없이 재전송이 가능하고 **메시지 손실에 대한 걱정이 사라짐**
- 자연스러운 백프레셔 핸들링
  - 카프카의 클라이언트는 풀 (pull) 방식으로 동작
  - 풀 방식의 장점으로는 **자기 자신의 속도로 데이터를 처리 가능**
- 강력한 파티셔닝
  - 논리적으로 토픽을 여러 개로 나누어 다른 파티션과 관계 없이 처리 가능
  - 이로 인해 수평 확장 가능
- 로그 컴팩션
  - 스냅샷 역할 가능

<br>

## 1.2. 카프카를 도입함으로써 해결 가능한 고민들

- 동기/비동기 데이터 전송에 대한 고민이 있는가?
- 실시간 데이터 처리에 대한 고민이 있는가?
- 현재의 데이터 처리에 한계를 느끼는가?
- 새로운 데이터 파이프라인이 복잡하다고 느끼는가?
- 데이터 처리의 비용 절감을 고려하고 있는가?

<br>

## 1.3. 카프카의 주요 특징

- 높은 처리량과 낮은 지연시간
  - RabbitMQ 가 응답 속도는 더 빠르지만 처리량까지 고려하면 카프카가 압도적
- 높은 확장성
  - 아무리 처리량이 높은 시스템이라도 한계가 존재하기 때문에 확장이 용이해야 함
- 고가용성
  - 초기에는 무엇보다 빠른 처리가 목표였지만 2013 년에 리플리케이션 (replication) 이 추가되면서 고가용성도 확보
- 내구성
  - 프로듀서가 메시지를 전송할 때 `acks` 옵션으로 메시지의 내구성 강화 가능
  - 안전한 저장소인 카프카의 로컬 디스크에 저장됨
  - 컨슈머가 메시지를 가져가도 메시지가 삭제되지 않고 **지정된 설정 시간 또는 로그의 크기만큼 로컬 디스크에 보관**
  - 버그나 장애가 발생해도 과거 메시지들을 가져와 처리 가능
- 개발 편의성
  - 메시지를 전송하는 프로듀서 (producer) 와 메시지를 가져오는 컨슈머 (consumer) 가 완벽하게 분리됨
  - 서로 영향을 주지 않기 때문에 각각 개발 가능