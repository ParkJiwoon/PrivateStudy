# 목차

- [Spring Core 패키지에서의 리액티브](#spring-core-패키지에서의-리액티브)
  - [리액티브 타입으로 형변환 지원](#리액티브-타입으로-형변환-지원)
  - [리액티브 I/O](#리액티브-io)
- [웹에서의 리액티브](#웹에서의-리액티브)
- [스프링 데이터에서의 리액티브](#스프링-데이터에서의-리액티브)
- [스프링 세션에서의 리액티브](#스프링-세션에서의-리액티브)
- [스프링 시큐리티에서의 리액티브](#스프링-시큐리티에서의-리액티브)
- [스프링 클라우드에서의 리액티브](#스프링-클라우드에서의-리액티브)
- [스프링 테스트에서의 리액티브](#스프링-테스트에서의-리액티브)
- [리액티브 모니터링하기](#리액티브-모니터링하기)
- [요약](#요약)

<br>

Reactor 프로젝트는 원래 스프링 프레임워크에 의존적이진 않지만 reactor 하나만으로는 복잡한 기능을 제공하는 애플리케이션을 만들 수 없습니다.

특히 여러 컴포넌트 사이의 결합도를 낮추는 의존성 주입 (DI, Dependency Injection) 을 지원하지 않습니다.

따라서 스프링 부트와 함께 사용해야 애플리케이션 개발이 가능한데, 기존의 스프링 생태계는 기본적으로 블로킹 데이터 모듈을 사용하기 때문에 리액티브를 사용해도 이점이 별로 없었습니다.

그래서 스프링 팀은 전체 패러다임 자체를 변경하기로 결정했고, 다수의 리액티브 모듈을 제공합니다.

<br>

# Spring Core 패키지에서의 리액티브

스프링 코어는 스프링 생태계의 핵심 모듈입니다.

스프링 프레임워크 5.x 에서는 RxJava 1 / 2 및 리액터 프로젝트 3 과 같은 리액티브 스트림 및 리액터 라이브러리에 대해 기본적으로 지원합니다.

<br>

## 리액티브 타입으로 형변환 지원

리액티브 스트림 스펙을 지원하기 위한 가장 대표적인 개선 중 하나는 `ReactiveAdapter` 및 `ReactiveAdapterRegistry` 의 도입입니다.

`ReactiveAdapter` 클래스는 임의의 타입을 `Publisher<T>` 로 변환하거나 임의의 `Publisher<T>` 를 `Object` 로 변환하는 두 가지 기본 메서드를 제공합니다.

```java
class ReactiveAdapter {
	<T> Publisher<T> toPublisher(@Nullable Object source) { 
		/* Object -> Publisher<T> */ 
	}

	Object fromPublisher(Publisher<?> publisher) { 
		/* Publisher<T> -> Object */ 
	}
}
```

<br>

위 클래스를 상속하면 RxJava 2 의 `Maybe` 타입에 대한 변환을 제공하는 Custom ReactiveAdapter 를 만들 수 있습니다.

```java
public class MaybeReactiveAdapter extends ReactiveAdapter {
    public MaybeReactiveAdapter() {
        super(
                ReactiveTypeDescriptor
                        .singleOptionalValue(Maybe.class, Maybe::empty),
                rawMaybe -> ((Maybe<?>) rawMaybe).toFlowable(),
                publisher -> Flowable.fromPublisher(publisher).singleElement()
        );
    }
}
```

<br>

그리고 위의 Custom ReactiveAdapter 를 간편하게 생성하기 위한 `ReactiveAdapterRegistry` 를 제공합니다.

`ReactiveAdapterRegistry` 는 다양한 리액티브 타입에 대한 인스턴스 풀을 갖고 있어서 여러 곳에서 사용할 수 있는 싱글턴 인스턴스를 제공하기 때문에 어댑터를 등록하거나 특정 자바 클래스를 매개 변수로 한 어댑터를 얻을 수 있습니다.

```java
// ReactiveAdapterRegistry 이용해서 어댑터 등록
ReactiveAdapterRegistry
        .getSharedInstance()
        .registerReactiveType(
                ReactiveTypeDescriptor
                        .singleOptionalValue(Maybe.class, Maybe::empty),
                rawMaybe -> ((Maybe<?>) rawMaybe).toFlowable(),
                publisher -> Flowable.fromPublisher(publisher).singleElement()
        );

// ReactiveAdapterRegistry 를 사용해서 커스텀 어댑터 생성
ReactiveAdapter maybeAdapter = ReactiveAdapterRegistry
        .getSharedInstance()
        .getAdapter(Maybe.class);
```

<br>

## 리액티브 I/O

또한 리액티브 지원을 위해 Core I/O 패키지를 보강했습니다.

기존의 `ByteBuffer` 클래스는 저장된 바이트에 액세스하기 위해 버퍼 내용을 힙 메모리로 복사해야 합니다.

<br>

그래서 네티에서 제공하는 효율적인 메모리 사용과 버퍼 재사용이라는 특성을 제대로 활요할 수 없었지만 `DataBuffer` 를 도입하여 이를 가능하게 했습니다.

그리고 스프링 코어 버전 5 에는 I/O (네트워크, 자원, 파일 등과의 상호 작용) 작업을 리액티브 스트림 형태로 할 수 있게 해주는 `DataBufferUtils` 클래스가 있습니다.

예를 들어 셰익스피어의 햄릿 파일 (hamlet.txt) 을 다음과 같이 배압 (Back Pressure) 지원이 되는 리액티브 스타일로 읽을 수 있습니다.

```java
// DataBufferUtils 클래스로 txt 파일 읽기
Flux<DataBuffer> hamlet = DataBufferUtils
        .read(
                new DefaultResourceLoader().getResource("hamlet.txt"),
                new DefaultDataBufferFactory(),
                1024
        );

// DataBufferUtils.read 클래스의 내부 로직
// readAsynchronousFileChannel 을 사용해서 Flux 타입으로 리턴해준다.
public static Flux<DataBuffer> read(
        Resource resource, long position, DataBufferFactory bufferFactory, int bufferSize) {

    try {
        if (resource.isFile()) {
            File file = resource.getFile();
            return readAsynchronousFileChannel(
                    () -> AsynchronousFileChannel.open(file.toPath(), StandardOpenOption.READ),
                    position, bufferFactory, bufferSize);
        }
    }
    catch (IOException ignore) {
        // fallback to resource.readableChannel(), below
    }
    Flux<DataBuffer> result = readByteChannel(resource::readableChannel, bufferFactory, bufferSize);
    return position == 0 ? result : skipUntilByteCount(result, position);
}
```

<br>

스프링 코어에서 리액티브와 관련된 중요한 기능은 **리액티브 코덱 (Reactive Codec)** 입니다.

리액티브 코덱을 이용하면 `DataBuffer` 인스턴스의 스트림을 객체의 스트림으로 변환하는 작업을 매우 간편하게 할 수 있습니다.

이를 위해 스트림의 데이터를 인코딩, 디코딩 하는 `Encoder` 및 `Decoder` 인터페이스가 있습니다.

```java
interface Encoder<T> {
    ...

    Flux<DataBuffer> encode(Publisher<? extends T> inputStream, ...);
}

interface Decoder<T> {
    ...

    Flux<T> decode(Publisher<DataBuffer> inputStream, ...);
    Mono<T> decodeToMono(Publisher<DataBuffer> inputStream, ...);
}
```

<br>

두 인터페이스는 리액티브 스트림의 `Publisher` 와 함께 사용하며 `DataBuffer` 인스턴스 스트림의 객체에 대한 인코딩 및 디코딩을 허용합니다.

이를 사용해서 얻는 이점은 논블로킹 방식으로 직렬화된 데이터를 자바 객체로, 또는 그 반대로 변환 가능하다는 겁니다.

<br>

게다가 데이터 인코딩 및 디코딩을 리액티브 스트림의 이점을 그대로 활용할 수 있습니다.

그래서 전체 데이터 셋을 다 받기 전에 디코딩을 시작해서 총 처리 시간을 줄일 수 있고, 반대로 객체의 전체 목록을 다 받기 전에 인코딩을 시작하고 I/O 채널로 보내서 양방향 처리 속도를 모두 향상시킬 수 있습니다.

<br>

# 웹에서의 리액티브

스프링 부트 2에는 웹플럭스라는 새로운 웹 스타터 그룹이 포함되어 있습니다.

웹플럭스는 높은 처리량과 빠른 반응 속도를 필요로 하는 애플리케이션 개발에 새로운 가능성을 제공합니다.

스프링 웹플럭스 모듈은 리액티브 스트림 어댑터 위에 구축되며, 일반적인 Servlet API 3.1 기반 서버를 지원함과 동시에 Netty 및 Undertow 와 같은 서버 엔진과도 통합됩니다.

<br>

스프링 웹플럭스는 리액터 3 을 사용하기 때문에 별도의 노력 없이 리액티브 프로그래밍을 사용할 수 있으며, 프로젝트 리액터와 네티 통합 환경에서 애플리케이션을 실행할 수 있습니다.

그리고 내장된 배압 지원 기능을 제공하므로 I/O 안정성을 보장합니다.

클라이언트 측면에서는 `WebClient` 클래스를 사용해서 논블로킹 통신이 가능합니다.

<br>

웹플럭스의 모듈 도입과 함께 WebMVC 에서도 리액티브 스트림을 사용할 수 있습니다.

스프링 5 에서 WebMVC 는 서블릿 API 3.1 이하 버전을 지원하지 않기 때문에 서블릿 스펙에 맞게 논블로킹 I/O 를 지원합니다.

비동기 동작은 제대로 구현하는 것에 비해 논블로킹 I/O 관련해서는 완벽하게 지원하는 건 아니기 때문에 `ResponseBodyEmitterReturnValueHandler` 클래스를 업그레이드 했습니다.

`Emitter` 핸들러는 무한한 스트림이 될 수 있는 `Publisher` 클래스를 WebMVC 모듈의 구조를 해치지 않으면서 리액티브 타입으로 처리할 수 있게 합니다.

그래서 `Flux`, `Mono` 와 같은 리액티브 타입을 처리하기 위한 `ReactiveTypehandler` 클래스가 도입되었습니다.

<br>

WebMVC 에서도 `WebClient` 를 사용할 수 있습니다.

![](https://github.com/ParkJiwoon/PrivateStudy/blob/master/books/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%81-5-%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/images/reactive-1.png?raw=true)

<br>

그림에서 볼 수 있는 차이점은 WebMVC 가 서블릿 API 와 통합하는 부분에서 Read/Write 에 대해 블로킹 방식으로 처리된다는 점입니다.

그리고 WebMVC 는 모든 블로킹 Read/Write 작업에 대해 내부적으로 쓰레드풀을 사용하기 때문에 이로 인한 예외 상황을 피하려면 적절한 설정을 추가해야 합니다.

반면에 WebFlux 통신 모델은 자체 처리 흐름을 정의할 수 있는 전송 프로토코로가 네트워크 처리량에 의존하고 있습니다.

리액티브 웹에 대해서는 **6장 웹플럭스 - 비동기 논블로킹 통신** 챕터에서 좀더 자세히 다룰 예정입니다.

<br>

# 스프링 데이터에서의 리액티브

Spring Data 프로젝트는 Repository 패턴을 이용해서 데이터 액세스를 편하게 하는 추상화를 제공합니다.

기존의 스프링 데이터는 스토리지 영역에 대해 동기식 블로킹 액세스를 제공했으나 5 버전부터는 리액터와 리액티브 타입을 이용해 리액터 워크 플로와 쉽게 통합할 수 있는 `ReactiveCurdRepository` 를 제공합니다.

게다가 `ReactiveCurdRepository` 를 확장해서 스토리지 메서드와 통합되는 다수의 모듈을 제공합니다.

![](https://github.com/ParkJiwoon/PrivateStudy/blob/master/books/%EC%8B%A4%EC%A0%84-%EC%8A%A4%ED%94%84%EB%A7%81-5-%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/images/reactive-2.png?raw=true)

<br>

위의 모듈들은 모두 스프링 부트를 통해 지원되며 개별적인 starter 모듈을 제공합니다.

게다가 이런 NoSQL 데이터베이스 뿐만 아니라 머지않아 리액티브 JDBC 커넥션이 제공될 것입니다.

데이터베이스에 대한 내용은 **7장 리액티브 방식으로 데이터베이스 사용하기** 에서 다룹니다.

요약하면, 스프링 데이터 버전 5 는 애플리케이션에서 요구하는 웹 엔드포인트 ~ 데이터베이스 종단 간의 데이터 흐름을 리액티브 흐름으로 완성했습니다.

<br>

# 스프링 세션에서의 리액티브

스프링 세션 모듈은 리액티브를 지원하기 위해 리액터의 `Mono` 타입으로 지정된 세션에 대한 비동기 논블로킹 액세스를 허용하는 `ReactiveSessionRepository` 를 도입했습니다.

그 외에도 리액티브 스트링 데이터를 통한 세션 저장소로 `Redis` 를 제공하기도 합니다.

`Redis WebSession` 을 리액티브하게 사용하기 위해서는 3 가지 의존성을 결합해서 사용해야 합니다.

```java
compile "org.springframework.session:spring-session-data-redis"
compile "org.springframework.boot:spring-boot-starter-webflux"
compile "org.springframework.boot:spring-boot-starter-data-redis-reactive"
```

<br>

# 스프링 시큐리티에서의 리액티브

스프링 5 에서는 스프링 시큐리티 모듈의 지원도 향상됐습니다.

과거의 스프링 시큐리티는 `SecurityContext` 인스턴스의 저장 방법으로 `ThreadLocal` 을 사용했습니다.

이 기술은 한 스레드 내에서는 잘 동작하지만 비동기 통신이 발생할 때는 문제가 발생합니다.

문제를 해결하기 위해 `ThredLocal` 내용을 다른 스레드로 전송하기 위한 추가적인 공수를 해줘야 하는데, 이 작업을 스레드 인스턴스 사이에 전환이 발생하느 곳마다 해줘야 합니다.

스프링 프레임워크는 이런 `ThreadLocal` 을 확장해서 쓰레드 간의 `SecurityContext` 전달을 단순화 했지만, 리액티브 프로그래밍 패러다임을 적용할 때는 여전히 문제가 있습니다.

다행히 차세대 스프링 시큐리티는 `Flux` 또는 `Mono` 스트림 내에서 `SecurityContext` 를 전송하기 위해 리액터의 컨텍스트를 사용합니다.

자세한 내용은 **6장 웹플럭스 - 비동기 논블로킹 통신** 에서 다룹니다.

<br>

# 스프링 클라우드에서의 리액티브

스프링 클라우드, 특히 게이트웨이에도 리액티브 프로그래밍 패러다임이 영향을 주었습니다.

스프링에서 오랫동안 사용하던 게이트웨이는 **스프링 클라우드 넷플릭스 Zuul** 모듈이었습니다.

동기식 블록킹으로 요청을 라우팅 하는 서블릿 API 기반이기 때문에 서버 성능 향상을 위해선 스레드 풀을 관리하는 방법 뿐이었습니다.

하지만 이건 리액티브 스타일도 아닐 뿐더러 확장성에도 문제가 있습니다.

원인에 대한 자세한 내용은 **6장 웹플럭스 - 비동기 논블로킹 통신** 에서 다룹니다.

<br>

# 스프링 테스트에서의 리액티브

테스트에서도 웹플럭스 기반 웹 애플리케이션을 테스트 할 수 있는 `WebTestClient` 를 제공합니다.

리액티브 스트림의 `Publisher` 를 테스트하기 위해 리액터 프로젝트는 리액터 테스트 모듈을 제공합니다.

리액티브 테스트의 세부 사항은 **9장 리액티브 애플리케이션 테스트하기** 에서 다룹니다.

<br>

# 리액티브 모니터링하기

리액터 프로젝트에는 모니터리을 위해 기본으로 제공하는 지표들이 있습니다.

리액티브 스트림 내에서 여러 이벤트를 추적할 수 있는 `Flux#metrics()` 메서드가 있습니다.

하지만 수동으로 등록된 모니터링 지점 외에도 많은 내부 프로세스를 추적해서 운영 통계를 작성해야 합니다.

이를 위해 스프링 프레임워크 생태계는 향상된 스프링 부트 액추에이터 모듈을 제공합니다.

차세대 스프링 액추에이터는 웹플럭스와 완벽하게 통합되며 비동기 논블로킹 프로그래밍을 사용합니다.

스프링 클라우드 슬루스 (Spring Cloud Sleuth) 모듈을 사용하면 리액터 프로젝트로 리액티브 프로그래밍을 지원하므로 응용 프로그램 내의 모든 리액티브 워크플로우를 추적할 수 있습니다.

<br>

요약하면, 스프링 프레임워크는 리액티브를 지원하는 것 뿐만 아니라 세부적인 애플리케이션 모니터링을 포함한 운영 환경에서도 사용 가능한 솔루션을 제공합니다.

이 주제는 **10장 자! 드디어 릴리즈다** 에서 다룹니다.

<br>

# 요약

스프링 부트는 2.x 버전부터는 리액티브 스택에 대해서도 훌륭하게 지원하도록 발전했습니다.

이 장에서는 세부 사항은 건너뛰면서 간단하게 다루었지만 다음 장부터는 스프링 Webflux 모듈부터 시작해서 어떤 내용들이 개선되었는지 자세히 알아봅니다.
