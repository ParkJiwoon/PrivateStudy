# Cache 전략

# Overview

우리가 사용하는 캐시는 여러가지 전략이 존재합니다.

<br>

# 1. Cache 종류

- 로컬 캐시 (EHcache)
- DB 내부 캐시
- CDN
- In-Memory 캐시 (Redis, Memcached)

<br>

# 2. 캐싱하기에 적절한 데이터

- 자주 조회됨
- 데이터가 자주 변경되지 않음
- 연산이 무거움
- 데이터의 정합성이 덜 중요한 경우
  - 예를 들어 페이스북, 인스타 피드 같은 경우에는 게시글 몇 개 좀 빠져도 큰 문제 없음
  - 금융권 같은 돈 관련된 서비스에서는 데이터가 틀어질 가능성도 있어서 신경써야함

<br>

# 3. Cache Aside

1. 캐시에 데이터가 있는지 확인
2. 데이터가 존재하면 (Cache Hit) 해당 캐시 데이터를 반환
3. 데이터가 존재하지 않으면 (Cache Miss) DB 에서 데이터를 가져온 후 캐시에 저장하고 데이터를 반환

애플리케이션에서 가장 일반적으로 사용되는 캐시 전략입니다.

주로 읽기 작업이 많은 애플리케이션에 적합합니다.

캐시가 분리되어 있기 때문에 **캐시 클러스터에 오류가 발생해도 데이터를 가져오는 데 문제가 없습니다.**

하지만 Cache Hit 의 경우 DB 를 확인하지 않기 때문에 **캐시가 최신 데이터를 가지고 있는지 (동기화) 가 중요합니다.**

<br>

# 4. Read Through

Cache Aside 와 비슷하지만 데이터 동기화를 라이브러리 또는 캐시 제공자에게 위임하는 방식이라는 차이점이 있습니다.

마찬가지로 읽기 작업이 많은 경우에 적합하며 두 방법 다 데이터를 처음 읽는 경우에는 Cache Miss 가 발생해서 느리다는 특징이 있습니다.

<br>

# 5. Write Through

1. 캐시에 데이터를 추가하거나 업데이트
2. 캐시가 DB 에 동기식으로 데이터 갱신
3. 캐시 데이터를 반환

쓰기 작업의 방법 중 하나입니다.

동기화까지 완료한 후에 데이터를 반환하기 때문에 캐시를 항상 최신 상태로 유지할 수 있다는 장점이 있습니다.

캐시 및 DB 를 동기식으로 갱신한 후에 최종 데이터 반환이 발생하기 때문에 전반적으로 느려질 수 있습니다.

<br>

# 6. Write Behind (Write Back)

1. 캐시에 데이터를 추가하거나 업데이트
2. 캐시는 이벤트 큐에 이벤트 추가
3. 캐시 데이터 반환
4. 이벤트 큐는 비동기식으로 DB 업데이트

캐시와 DB 동기화를 비동기로 하는 방법이며 동기화 과정이 생략되기 때문에 쓰기 작업이 많은 경우에 적합합니다.

다른 캐시 전략에 비해 구현하기 어려운 편이며 캐시가 다운되면 이벤트 큐에 데이터 추가가 되지 않기 때문에 데이터가 유실될 수 있습니다.

<br>

# 7. Refresh Ahead

캐시가 만료되기 전에 최근에 사용한 주요 캐시들을 갱신합니다.

미래에 사용될 데이터가 뭔지 예측할 수 있다면 속도가 빨라지겠지만, 그렇지 않다면 Cache Miss 로 인해 성능이 저하될 수도 있습니다.

<br>

# Reference

- [What is Caching ?](https://medium.com/system-design-blog/what-is-caching-1492abb92143)