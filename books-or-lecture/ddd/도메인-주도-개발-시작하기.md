# Ch 6. 표현 영역과 응용 영역

## 6.1. 표현 영역과 응용 영역

사용자와 도메인을 연결해주는 게 표현 영역과 응용 영역

- 표현 영역: 사용자의 요청을 해석
- 응용 영역: 사용자가 원하는 기능을 제공

사용자의 요청과 응용 영역에서 요구하는 파라미터의 형식이 다르기 때문에 표현 영역에서 변환 필요

응용 영역은 표현 영역에 의존하지 않기 때문에 사용자와의 상호 작용 (요청, 응답) 은 표현 영역에서 담당

<br>

## 6.2. 응용 서비스의 역할

도메인 영역과 표현 영역을 연결해주는 창구 역할

응용 서비스의 형태는 최대한 단순하게 가짐

1. Repository 에서 Aggregate 를 가져옴
2. Aggregate 의 도메인 기능을 실행
3. 결과를 표현 영역에 리턴

만약 응용 서비스가 복잡하다면 응용 서비스에 도메인 로직을 구현하고 있을 가능성이 높음

응용 서비스는 트랜잭션 내에서 실행되어야 함

<br>

### 6.2.1. 도메인 로직 넣지 않기

도메인 로직을 응용 서비스에 구현하면 여러 응용 서비스에 중복된 기능을 구현하게 될 가능성이 높음

도메인에 관련된 기능은 도메인 내에 넣어서 **코드의 응집성을 높이고 중복을 줄여야 함**

<br>

## 6.3. 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 Facade 패턴과 같은 역할을 함

<br>

### 6.3.1. 응용 서비스의 크기

응용 서비스의 구현 방법은 크게 두가지가 존재

회원 기능 (Member) 을 예시로 듬

1. 한 응용 서비스에서 모든 기능 구현
   - `MemberService` 를 하나 만들고 메서드로 기능 구분
   - 장점
     - 중복된 기능을 별도의 private 메서드로 분리해서 공통화 할 수 있음
   - 단점
     - 여러 기능이 한 클래스에 들어가다보니 시간이 지날수록 코드라인 수가 늘어남
     - 관련 없는 기능들도 한 클래스 내에 섞이면서 알아보기 힘들게 만듬
     - 이후에 추가될 기능이 분리해야 함에도 불구하고 습관적으로 해당 응용 서비스에 그대로 넣음
2. 구분되는 기능 별로 응용 서비스 클래스를 따로 구현
   - `ChangePasswordService`, `LeaveService` 등등 기능별로 클래스를 만들어서 구분
   - 장점
     - 특정 기능에만 집중하기 때문에 한 클래스 내의 코드량이 줄어들음 (가독성이 좋아짐)
     - 관련 없는 코드들에는 영향을 주지 않음
     - 코드 중복 문제도 별도의 Helper 클래스로 분리하면 해결 가능
   - 단점
     - 클래스 (파일) 의 갯수가 많아짐

책 저자는 응용 서비스 클래스를 기능별로 구현하는 방식을 선호

<br>

### 6.3.2. 응용 서비스의 인터페이스와 클래스

인터페이스가 필요한 상황

1. 구현 클래스가 여러개 존재
2. 런타임에 구현 객체를 교체해야 할 때

하지만 응용 서비스는 런타임에 교체하는 경우가 거의 없고 구현 클래스가 여러개인 경우도 드뭄
(동일한 기능을 가진 `ChangePasswordService` 를 여러개 구현한 경우가 드물다는 뜻)

**인터페이스는 필요할 때만 만드는게 좋다**

<br>

### 6.3.3. 메서드 파라미터와 값 리턴

파라미터가 2개 이상이면 DTO 를 만들어 사용하는 것이 편하다

응답으로는 애그리거트 객체를 직접 전달하지 않고 식별값을 전달하는게 좋다

애그리거트 객체가 표현 영역까지 전달 되면 도메인 로직 실행을 여러 곳에 분산 시키는 꼴이 될 수 있음

<br>

### 6.3.4. 표현 영역에 의존하지 않기

표현 영역에서 사용하는 `HttpRequest`, `HttpSession` 같은 데이터는 응용 서비스에 전달하면 안됨

응용 영역이 표현 영역에 의존하기 시작하면 응용 영역만 단독으로 테스트하기 어려워짐

<br>

## 6.4. 표현 영역

표현 영역의 책임

- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어
- 사용자의 요청 (Request) 을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공 (Response)
  - 응용 서비스에서 요구하는 형식 (파라미터) 으로 변경하는 기능도 포함
- 사용자의 세션을 관리

<br>

## 6.5. 값 검증

값 검증은 표현 영역과 응용 영역 두 곳에서 모두 수행 가능

필요에 따라 각 영역마다 나누어서 개발할 수도 있지만 응용 영역에서 모두 검증하는 편이 응용 서비스의 완성도가 높아짐

<br>

# 7. 도메인 서비스

## 7.1. 여러 애그리거트가 필요한 기능

도메인 영역의 코드를 작성하다 보면 한 애그리거트로 기능을 구현할 수 없을 때가 존재

대표적인 예가 결제 금액 계산 로직

- 상품 애그리거트 : 구매하는 상품의 가격이 필요
- 주문 애그리거트 : 상품별로 구매 개수 필요
- 할인 애그리거트 : 상품의 할인 정책에 따라 금액 계산 필요
- 회원 애그리거트 : 회원 등급에 따라 추가 할인 가능

위처럼 여러 애그리거트가 얽히면 특정 애그리거트가 담당하기 애매해짐

이럴 때 사용하는게 도메인 서비스

<br>

## 7.2. 도메인 서비스

도메인 서비스는 크게 두가지 상황에 사용

- 계산 로직 : 여러 애그리거트가 필요하거나, 한 애그리거트에 넣기에는 다소 복잡한 계산
- 외부 시스템 연동이 필요한 도메인 로직 : 타 시스템을 함께 사용해야 하는 도메인 로직

<br>

### 7.2.1. 계산 로직과 도메인 서비스

도메인 서비스가 애그리거트, 밸류와 다른 점은 **상태 없이 로직만 구현한다는 점**

이름은 도메인의 의미가 드러나는 용어로 지음

도메인 서비스를 애그리거트에서 사용할 때는 파라미터로 전달 받아 사용 (객체를 직접 주입하면 의존성이 생겨버림)

반대로 도메인 서비스에 애그리거트를 파라미터로 전달할 수도 있음

파라미터로 전달해주는 주체는 응용 서비스

즉, **도메인 서비스의 생성은 응용 서비스에서 하고 직접 사용하거나 애그리거트의 파라미터로 넘겨서 사용**한다

도메인 서비스는 응용 로직이 아닌 도메인 로직만 수행해야 함

도메인 로직의 기준: 애그리거트의 상태를 변경하거나 상태 값을 계산하는지 검사

<br>

### 7.2.2. 외부 시스템 연동과 도메인 서비스

외부 시스템 연동 기능은 보통 도메인 영역에 인터페이스를 구현하고 구현체를 인프라 영역에 구현

<br>

# 8. 애그리거트 트랜잭션 관리

## 8.1. 애그리거트와 트랜잭션

애그리거트에 대해 사용할 수 있는 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금 두 가지 방식 존재

<br>

## 8.2. 선점 잠금 (Pessimistic Lock)

먼저 애그리거트를 구한 쓰레드가 애그리거트 사용이 끝날 때까지 다른 쓰레드가 수정하지 못하게 하는 방식

다른 쓰레드는 먼저 선점된 애그리거트를 사용할 수 있을 때까지 Blocking 상태가 됨

<br>

### 8.2.1. 선점 잠금과 교착 상태

선점 잠금을 사용하면 교착 상태 (DeadLock) 에 빠질 수 있음

교착 상태란 1 쓰레드 - A 애그리거트, 2 쓰레드 - B 애그리거트

이렇게 두 쓰레드가 각각의 애그리거트를 선점한 채로 서로의 애그리거트를 선점하기 위해 무한히 대기하는 것을 말함

교착 상태를 해결하는 방법 중 하나로 대기 timeout 을 거는 방법이 있음

<br>

## 8.3. 비선점 잠금

비선점 잠금은 동시 접근을 막지 않는 대신 변경한 데이터를 실제 DBMS 에 반영하는 시점에 변경 가능 여부를 확인하는 방식

비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 함

수정하기 직전에 버전값을 확인해서 변경 가능한 상태에서만 수정을 진행하고 버전 값을 1 증가시킴

<br>

## 8.4. 오프라인 선점 잠금 (Offline Pessimistic Lock)

선점 잠금은 단일 트랜잭션에 대해서만 동작

오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 변경을 막을 수 있음

예를 들면 수정 화면에서는 잠금 선점 - 수정 폼 요청 - 수정 요청 - 잠금 해제 순으로 진행할 수 있다

하지만 수정 폼 요청까지만 하고 수정을 하지 않고 페이지를 벗어나면 잠금 해제가 되지 않기 때문에 **잠금 유효 시간**이 필요

<br>

## Ch 9. 도메인 모델과 바운디드 컨텍스트

## 9.1. 도메인 모델과 경계

단일 모델로는 도메인을 완벽히 표현할 수 없다

논리적으로는 같은 존재여도 하위 도메인에 따라 다른 용어를 사용할 수 도 있다 (회원, 주문자, 배송자 등)

<br>

## 9.2. 바운디드 컨텍스트

한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 가짐

바운디드 컨텍스트의 경계를 잘 나누는게 중요함

일반적으로는 용어를 기준으로 나눔

<br>

팀적인 상황에 의해 전체 시스템을 한 개의 팀에서 구현하게 될 수도 있음

하나의 바운디드 컨텍스트에 여러 도메인이 존재하는데, 단일 모델을 사용하지 말고 도메인별로 나누는 게 중요하다

<br>

## 9.3. 바운디드 컨텍스트 구현

바운디드 컨텍스트는 표현 영역, 응용 서비스, 인프라 영역을 모두 포함

도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 테이블도 바운디드 컨텍스트에 포함

도메인 기능이 단순하다면 응용 서비스와 도메인 없이 표현 영역 - 서비스 - DAO 로 구성해도 상관없음

한 바운디드 컨텍스트에서 조회 기능과 변경 기능을 혼합해서 사용하는 CQRS 패턴도 있음

<br>

## 9.4. 바운디드 컨텍스트 간 통합

바운디드 컨텍스트끼리 통신하기 위해선 여러 가지 방법이 있음

- 직접 통신: REST API 호출
- 간접 통신: 메시지 큐 사용

<br>

## 9.5. 바운디드 컨텍스트 간 관계

두 바운디드 컨텍스트가 통신할 때 API 호출자는 API 제공자에게 의존한다

**API 고객 (하류 downstream) -> API 제공자 (상류 upstream)**

상류 컴포넌트는 하류 컴포넌트들이 사용할 수 있는 API 를 제공한다

하류 컴포넌트들은 상류 컴포넌트들이 제공하는 API 응답 모델에 의존하지 않도록 변환해서 사용해야 함

<br>

## 9.6. 컨텍스트 맵

개별 컨텍스트에 매몰되면 전체를 보지 못할 때가 있음

전체 비즈니스를 조망할 수 있는 지도가 필요한데 그게 컨텍스트 맵

컨텍스트 맵은 바운디드 컨텍스트 간의 관계를 표시한 것

컨텍스트 맵은 단순하게 만들 수 있으면서 전체적인 관계를 한눈에 알아볼 수 있다

<br>

# Ch 10. 이벤트

## 10.1. 시스템 간 강결합 문제

두개 이상의 도메인이 얽혀있을 때는 어떤 액션을 수행할 때 영향을 줄 수 있다

하지만 다른 도메인의 실패가 현재 도메인에 영향을 준다면 두 도메인은 강결합 되어 있다고 할 수 있다

바운디드 컨텍스트 간의 강결합을 없애기 위해선 이벤트를 사용할 수 있음

<br>

## 10.2. 이벤트 개요

이벤트의 정의는 "과거에 벌어진 어떤 것" 을 의미함

"암호 변경됨", "주문 취소됨" 등 어떤 사건은 이미 벌어진 후에 그걸 처리하는 거기 때문에 보통 과거형으로 씀

<br>

### 10.2.1. 이벤트 관련 구성요소

도메인 모델에 이벤트를 도입하기 위해선 네 개의 구성요소가 필요하다

- 이벤트
- 이벤트 생성 주체
  - 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
  - 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생
- 이벤트 디스패처 (퍼블리셔)
  - 이벤트 생성 주체와 핸들러를 연결해줌
- 이벤트 핸들러 (구독자)
  - 생성 주체가 발생한 이벤트를 전달받아 기능을 실행함

<br>

### 10.2.2. 이벤트의 구성

이벤트는 다음의 정보를 포함해야 함

- 이벤트 종류: 클래스 이름으로 표현
- 이벤트 발생 시간
- 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

<br>

### 10.2.3. 이벤트 용도

이벤트는 크게 두가지 용도로 사용됨

- 트리거
  - 도메인의 상태가 바뀔 때 다른 후처리를 실행하기 위한 이벤트
  - 결과 통지 (SMS, Email, Push) 등
- 서로 다른 시스템 간의 데이터 동기화
  - ex) 배송지를 변경하면 배송 서비스에 정보 전달

<br>

### 10.2.4. 이벤트 장점

- 서로 다른 도메인 로직이 섞이는 걸 방지
  - 다른 도메인을 알지 못해도 됨
  - 의존성이 사라짐
- 기능 확장 용이
  - 새로운 기능이 추가되어도 핸들러를 추가하면 됨
  - 기존 로직을 수정할 필요 없음

<br>

## 10.3. 이벤트, 핸들러, 디스패처 구현

Spring 과 관련된 코드 내용이라 정리하지 않음

<br>

## 10.4. 동기 이벤트 처리 문제

외부 시스템을 동기적으로 처리하면 에러 발생이나 timeout 에 영향을 받음

<br>

## 10.5. 비동기 이벤트 처리

이메일 전송 이벤트는 바로 처리될 필요 없음

1~2초 뒤에 도착해도 되고 10초 뒤에 도착해도 되고, 메일이 전송되지 않으면 다시 받기 기능도 이용할 수 있음

비슷하게 결제 취소 기능도 바로 해줄 필요 없이 수십초 내에 처리해 주면 됨

이렇게 **우리가 하는 구현 중 바로 처리하는게 아닌 일정 시간 안에만 후속 처리를 하면 되는 케이스가 많음**

이벤트 비동기 구현 방법은 여러개 존재

- 로컬 핸들러를 비동기로 실행
  - 별도 쓰레드로 실행
  - `@Async` 사용
- 메시지 큐 이용
  - Kafka 나 RabbitMQ 같은 메시징 시스템 사용
  - 필요하다면 글로벌 트랜잭션을 사용할 수 있지만 성능이 떨어짐
  - RabbitMQ 는 글로벌 트랜잭션과 클러스터, 고가용성을 지원하기 때문에 안정적
  - 카프카는 글로벌 트랜잭션은 없지만 높은 성능을 보여줌
- 이벤트 저장소와 이벤트 포워더 사용
  - DB 에 저장했다가 별도 프로그램으로 이벤트 핸들러에 전달하는 방법
  - 포워더가 주기적으로 저장소를 확인하여 이벤트를 가져와 실행
  - 이벤트를 물리적 저장소에 보관하기 때문에 핸들러가 이벤트 처리에 실패하면 포워더는 실패한 결과를 다시 읽어와 처리 가능 (로컬 트랜잭션 보장 가능)
- 이벤트 저장소와 이벤트 제공 API 사용
  - 포워더와 비슷하지만 API 서버를 사용한다는 점이 다름

<br>

## 10.6. 이벤트 적용 시 추가 고려 사항

- 이벤트 발생 주체를 `Event` 객체에 추가할 것인가?
  - 특정 주체가 발생 시킨 이벤트만 조회하는 게 불가능하기 때문에 이벤트 소스를 추가해서 구분해야 함
- 포워더에서 전송 실패를 얼마나 허용할 것인가?
  - 포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어와 전송을 시도
  - 특정 이벤트에서 계속 실패한다면 나머지 이벤트들도 딜레이 되기 때문에 재전송 횟수 제한 필요
- 이벤트 손실에 대한 고려
- 이벤트 순서
  - 순서가 중요한 경우 이벤트 저장소를 사용하는게 좋음
  - 메시징 시스템은 이벤트 발생 순서와 메시지 전달 순서가 다를 수 있음
- 이벤트 재처리
  - 동일 이벤트를 다시 처리해야 할 때 어떻게 할지
  - 가장 쉬운 방법은 마지막으로 처리한 이벤트의 순번을 기억하고 중복 이벤트가 발생하면 무시
  - 다른 방법은 이벤트를 멱등성으로 처리

<br>

### 10.6.1. 이벤트 처리와 DB 트랜잭션 고려

동기 이벤트와 비동기 이벤트 모두 트랜잭션을 고려해야 함

트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 방법 존재

이벤트 저장소를 사용한다면 트랜잭션 처리를 쉽게 가져갈 수 있음

<br>

# Ch 11. CQRS

## 11.1 단일 모델의 단점

객체 지향적인 ORM 을 사용하다보면 한번의 SELECT 쿼리로 가져올 데이터를 여러번에 가져와야 할 때가 있음

도메인 상태 변경에는 효과적이지만 단순 조회 기능에서는 오히려 성능 저하를 가져옴

상태 변경 모델과 조회 모델을 분리하는 방법이 CQRS

<br>

## 11.2. CQRS

상태 변경은 주로 한 애그리거트를 변경하지만 조회는 두 개 이상의 애그리거트가 필요할 때가 많음

조회 기능에서는 응용 서비스 없이 Controller 에서 바로 DAO 를 실행하는 경우도 있음

<br>

### 11.2.1. 웹과 CQRS

대규모 트래픽이 발생하는 웹 서비스에서 조회 속도를 높이기 위해 별도 처리를 하고 있다면

명령 모델과 조회 모델을 구분해보자

<br>

### 11.2.2. CQRS 장단점

장점
- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있음
- 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아짐
- 조회 성능을 향상시키는 데 유리함 (캐시 기술 적용, 특화 쿼리 사용)

단점
- 구현해야 할 코드가 더 많음 (트레이드오프 비용을 잘 생각해야 함)
- 더 많은 구현 기술 필요 (저장소 분리, 데이터 동기화 처리)