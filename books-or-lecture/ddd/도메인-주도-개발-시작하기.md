# Ch 6. 표현 영역과 응용 영역

## 6.1. 표현 영역과 응용 영역

사용자와 도메인을 연결해주는 게 표현 영역과 응용 영역

- 표현 영역: 사용자의 요청을 해석
- 응용 영역: 사용자가 원하는 기능을 제공

사용자의 요청과 응용 영역에서 요구하는 파라미터의 형식이 다르기 때문에 표현 영역에서 변환 필요

응용 영역은 표현 영역에 의존하지 않기 때문에 사용자와의 상호 작용 (요청, 응답) 은 표현 영역에서 담당

<br>

## 6.2. 응용 서비스의 역할

도메인 영역과 표현 영역을 연결해주는 창구 역할

응용 서비스의 형태는 최대한 단순하게 가짐

1. Repository 에서 Aggregate 를 가져옴
2. Aggregate 의 도메인 기능을 실행
3. 결과를 표현 영역에 리턴

만약 응용 서비스가 복잡하다면 응용 서비스에 도메인 로직을 구현하고 있을 가능성이 높음

응용 서비스는 트랜잭션 내에서 실행되어야 함

<br>

### 6.2.1. 도메인 로직 넣지 않기

도메인 로직을 응용 서비스에 구현하면 여러 응용 서비스에 중복된 기능을 구현하게 될 가능성이 높음

도메인에 관련된 기능은 도메인 내에 넣어서 **코드의 응집성을 높이고 중복을 줄여야 함**

<br>

## 6.3. 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 Facade 패턴과 같은 역할을 함

<br>

### 6.3.1. 응용 서비스의 크기

응용 서비스의 구현 방법은 크게 두가지가 존재

회원 기능 (Member) 을 예시로 듬

1. 한 응용 서비스에서 모든 기능 구현
   - `MemberService` 를 하나 만들고 메서드로 기능 구분
   - 장점
     - 중복된 기능을 별도의 private 메서드로 분리해서 공통화 할 수 있음
   - 단점
     - 여러 기능이 한 클래스에 들어가다보니 시간이 지날수록 코드라인 수가 늘어남
     - 관련 없는 기능들도 한 클래스 내에 섞이면서 알아보기 힘들게 만듬
     - 이후에 추가될 기능이 분리해야 함에도 불구하고 습관적으로 해당 응용 서비스에 그대로 넣음
2. 구분되는 기능 별로 응용 서비스 클래스를 따로 구현
   - `ChangePasswordService`, `LeaveService` 등등 기능별로 클래스를 만들어서 구분
   - 장점
     - 특정 기능에만 집중하기 때문에 한 클래스 내의 코드량이 줄어들음 (가독성이 좋아짐)
     - 관련 없는 코드들에는 영향을 주지 않음
     - 코드 중복 문제도 별도의 Helper 클래스로 분리하면 해결 가능
   - 단점
     - 클래스 (파일) 의 갯수가 많아짐

책 저자는 응용 서비스 클래스를 기능별로 구현하는 방식을 선호

<br>

### 6.3.2. 응용 서비스의 인터페이스와 클래스

인터페이스가 필요한 상황

1. 구현 클래스가 여러개 존재
2. 런타임에 구현 객체를 교체해야 할 때

하지만 응용 서비스는 런타임에 교체하는 경우가 거의 없고 구현 클래스가 여러개인 경우도 드뭄
(동일한 기능을 가진 `ChangePasswordService` 를 여러개 구현한 경우가 드물다는 뜻)

**인터페이스는 필요할 때만 만드는게 좋다**

<br>

### 6.3.3. 메서드 파라미터와 값 리턴

파라미터가 2개 이상이면 DTO 를 만들어 사용하는 것이 편하다

응답으로는 애그리거트 객체를 직접 전달하지 않고 식별값을 전달하는게 좋다

애그리거트 객체가 표현 영역까지 전달 되면 도메인 로직 실행을 여러 곳에 분산 시키는 꼴이 될 수 있음

<br>

### 6.3.4. 표현 영역에 의존하지 않기

표현 영역에서 사용하는 `HttpRequest`, `HttpSession` 같은 데이터는 응용 서비스에 전달하면 안됨

응용 영역이 표현 영역에 의존하기 시작하면 응용 영역만 단독으로 테스트하기 어려워짐

<br>

## 6.4. 표현 영역

표현 영역의 책임

- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어
- 사용자의 요청 (Request) 을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공 (Response)
  - 응용 서비스에서 요구하는 형식 (파라미터) 으로 변경하는 기능도 포함
- 사용자의 세션을 관리

<br>

## 6.5. 값 검증

값 검증은 표현 영역과 응용 영역 두 곳에서 모두 수행 가능

필요에 따라 각 영역마다 나누어서 개발할 수도 있지만 응용 영역에서 모두 검증하는 편이 응용 서비스의 완성도가 높아짐

<br>

# 7. 도메인 서비스

## 7.1. 여러 애그리거트가 필요한 기능

도메인 영역의 코드를 작성하다 보면 한 애그리거트로 기능을 구현할 수 없을 때가 존재

대표적인 예가 결제 금액 계산 로직

- 상품 애그리거트 : 구매하는 상품의 가격이 필요
- 주문 애그리거트 : 상품별로 구매 개수 필요
- 할인 애그리거트 : 상품의 할인 정책에 따라 금액 계산 필요
- 회원 애그리거트 : 회원 등급에 따라 추가 할인 가능

위처럼 여러 애그리거트가 얽히면 특정 애그리거트가 담당하기 애매해짐

이럴 때 사용하는게 도메인 서비스

<br>

## 7.2. 도메인 서비스

도메인 서비스는 크게 두가지 상황에 사용

- 계산 로직 : 여러 애그리거트가 필요하거나, 한 애그리거트에 넣기에는 다소 복잡한 계산
- 외부 시스템 연동이 필요한 도메인 로직 : 타 시스템을 함께 사용해야 하는 도메인 로직

<br>

### 7.2.1. 계산 로직과 도메인 서비스

도메인 서비스가 애그리거트, 밸류와 다른 점은 **상태 없이 로직만 구현한다는 점**

이름은 도메인의 의미가 드러나는 용어로 지음

도메인 서비스를 애그리거트에서 사용할 때는 파라미터로 전달 받아 사용 (객체를 직접 주입하면 의존성이 생겨버림)

반대로 도메인 서비스에 애그리거트를 파라미터로 전달할 수도 있음

파라미터로 전달해주는 주체는 응용 서비스

즉, **도메인 서비스의 생성은 응용 서비스에서 하고 직접 사용하거나 애그리거트의 파라미터로 넘겨서 사용**한다

도메인 서비스는 응용 로직이 아닌 도메인 로직만 수행해야 함

도메인 로직의 기준: 애그리거트의 상태를 변경하거나 상태 값을 계산하는지 검사

<br>

### 7.2.2. 외부 시스템 연동과 도메인 서비스

외부 시스템 연동 기능은 보통 도메인 영역에 인터페이스를 구현하고 구현체를 인프라 영역에 구현

<br>

# 8. 애그리거트 트랜잭션 관리

## 8.1. 애그리거트와 트랜잭션

애그리거트에 대해 사용할 수 있는 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금 두 가지 방식 존재

<br>

## 8.2. 선점 잠금 (Pessimistic Lock)

먼저 애그리거트를 구한 쓰레드가 애그리거트 사용이 끝날 때까지 다른 쓰레드가 수정하지 못하게 하는 방식

다른 쓰레드는 먼저 선점된 애그리거트를 사용할 수 있을 때까지 Blocking 상태가 됨

<br>

### 8.2.1. 선점 잠금과 교착 상태

선점 잠금을 사용하면 교착 상태 (DeadLock) 에 빠질 수 있음

교착 상태란 1 쓰레드 - A 애그리거트, 2 쓰레드 - B 애그리거트

이렇게 두 쓰레드가 각각의 애그리거트를 선점한 채로 서로의 애그리거트를 선점하기 위해 무한히 대기하는 것을 말함

교착 상태를 해결하는 방법 중 하나로 대기 timeout 을 거는 방법이 있음

<br>

## 8.3. 비선점 잠금

비선점 잠금은 동시 접근을 막지 않는 대신 변경한 데이터를 실제 DBMS 에 반영하는 시점에 변경 가능 여부를 확인하는 방식

비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 함

수정하기 직전에 버전값을 확인해서 변경 가능한 상태에서만 수정을 진행하고 버전 값을 1 증가시킴

<br>

## 8.4. 오프라인 선점 잠금 (Offline Pessimistic Lock)

선점 잠금은 단일 트랜잭션에 대해서만 동작

오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 변경을 막을 수 있음

예를 들면 수정 화면에서는 잠금 선점 - 수정 폼 요청 - 수정 요청 - 잠금 해제 순으로 진행할 수 있다

하지만 수정 폼 요청까지만 하고 수정을 하지 않고 페이지를 벗어나면 잠금 해제가 되지 않기 때문에 **잠금 유효 시간**이 필요