# 강의 링크

https://inf.run/RwNv

<br>

# 1. 마이크로 서비스 개념

## 1.1. 모노리스

- 기존에 많이 쓰는 방식
- 모든 서비스가 한 덩어리로 구성되어 있음
- 문제점
  - 시스템의 한 부분을 수정했을 때 전체를 재배포 해야함
  - 스케일 아웃 시 모노리스 전체가 확장
    - 트래픽이 몰리는 기능만 확장 시키는 게 효율적인데 불가능함

<br>

## 1.2. 마이크로서비스

- 애플리케이션이 여러 개의 서비스 조각으로 구성됨
- 서비스는 독립적인 기능을 제공하고 **저장소가 다른 서비스와 완벽히 격리됨**
- 독립적으로 수정, 배포, 확장 가능
- 각 서비스에서 다른 저장소에 접근 불가능하고 API 를 통해 다른 서비스에 요청해야 함
- 각 서비스는 서로 다른 언어, 데이터, 저장 기술 사용 가능
  - 서비스 1: Java/Oracle
  - 서비스 2: NodeJS/MySQL
- SOA 와의 차이점
  - 저장소까지도 완벽히 격리했기 때문에 저장소에 변경이 생겨도 모든 서비스에 영향이 가지 않음
  - SOA 는 하나의 공통 모듈 서비스가 있는데 MSA 는 공통 모듈보다는 각 서비스에 중복된 기능이 존재하더라도 서비스끼리 최대한 격리하려고 노력함

<br>


# 2. 도메인 주도 설계 (전략적 설계 이해)

MSA 를 구축하려다 보니 DDD 가 떠오름

이벤트 스토밍을 사용해서 쉽게 DDD 를 구축할 수 있음

<br>

## 2.1. Bounded Context (바운디드 컨텍스트)

모호하게 공통되는 단어를 사용하지 말고 최대한 모델을 세세하게 나눌 수 있는 단어를 사용해라

예를 들면 사용자 라는 단어보다는 회원, 방문자(비회원) 으로 구분하는게 나중에 헷갈리지 않음

<br>

특히 특정 서비스의 고객이라는 단어를 Customer 로 사용하면 각 서비스 별로 용어가 헷갈릴 수 있음

그러니 같은 고객이어도 서비스에 따라 Subscriber (구독자), Passenger (탑승자), Buyer (구매자) 같은 느낌으로 컨텍스트 구분이 필요함

같은 고객이라는 정보여도 최소한의 정보만 공통으로 묶고 컨텍스트 별로 분리를 하는게 좋음

<br>

## 2.2. Context Mapping (컨텍스트 매핑)

Bounded Context 는 독립적이지만 상호작용이 필요하고 접점이 존재함 이것을 Contract 라고 함

- 협력형 패턴
  - 파트너십
    - 두 컨텍스트가 굉장히 밀접함
  - 공유 영역
    - 두 컨텍스트가 공유하는 영역 
- 사용자-제공자 패턴
  - 많이 사용되는 패턴
  - Supplier - Customer
  - Upstream - Downstream
- 분리형 노선 패턴

<br>

# 2.3. 이벤트 스토밍 (Event Storming)

기획, 디자이너, 개발자 전부 모여서 아키텍쳐를 구상하는 건데.. 사실 잘 와닿진 않음

<br>

# 4. 도메인 주도 설계 (전술적 설계 이해)

마이크로서비스 내 비지니스 로직 구현 패턴 5가지 유형 존재

- 트랜젝션 스크립트 패턴
- 액티브 레코드 패턴
- 도메인 모델 패턴
- 어그리거트 도메인 모델 패턴
- 이벤트 소싱 패턴

<br>

## 4.1. 트랜잭션 스크립트 패턴

전통적인 방식이며 이미 많이 사용하는 방식

DB 에 접근하여 스크립트를 호출하듯이 주르륵 비즈니스 로직을 나열하는 것

- 장점: 단순하고 이해하기 쉬움
- 단점: 비즈니스 로직이 복잡할 수록 중복이 발생하기 쉬움

<br>

## 4.2. 액티브 레코드 패턴

Active Record 라는 전용 객체를 사용하여 자료 구조를 표현하고 CRUD, ORM 연계

Entity 라는 객체라고 불리며 약간의 비즈니스 로직을 포함할 순 있지만 큰 흐름은 Service 의 행위에 의해 처리됨

<br>

## 4.3. 도메인 모델 패턴

행위 (behavior) + 자료구조 (data) 를 통해 비즈니스 로직을 구현

주요 비즈니스 로직은 도메인 모델에 위임하고 Service 는 흐름만 관리

<br>

## 4.4. Aggregate 패턴

도메인 모델의 비대함을 관리하기 위해 하나로 묶어주는 (Aggregate) 패턴

한 개의 Entity 와 여러 개의 VO 로 구현

- VO (Value Object)
  - 고유의 식별자를 가지진 않지만 개념적으로 하나를 표현
  - 프로퍼티의 타입으로 int, String 등을 직접적으로 사용하기 보다는 Name, PhoneNumber 처럼 각각 
  - 상태를 변경할 수 없는 (불변) 값만을 가진 객체
  - 객체를 변경할 때는 객체 자체를 완전히 교체함 (읽기 전용)
- Entity
  - 도메인의 교유 개념이고 다른 객체와 구별할 수 있는 식별자 (고유 식별자) 를 가짐
  - 고유 식별자가 있기 때문에 데이터 변경이 가능 (주문에서 배송지 정보는 변겨되어도 주문 번호는 변경되지 않음)
- Aggregate
  - 관련 객체를 하나로 묶은 군집
  - Aggregate Root 를 사용해서 Aggregate 내의 다른 Entity, VO 접근
  - 설계 고려사항
    - 하나의 트랜잭션에서는 하나의 Aggregate 만 수정
    - 하나의 일을 잘 수행할 수 있도록 작게 설계
    - 한 Aggregate 에서 다른 Aggregate 객체를 직접 참조하지 말고 식별자 (ID) 를 통해 참조하는 게 좋음
    - 한 트랜잭션 내에 여러 개의 Aggregate 가 변경되는 경우 다른 Aggregate 의 갱신은 **비동기 통신을 활용해서 결과적 일관성**을 맞춰야함
      - 결과적 일관성은 일정시간은 데이터가 일치하지 않아도 어느 시점에는 결국 일치한다는 뜻
- Domain Event
  - 비즈니스 도메인에서 일어난 중요한 이벤트를 설명하는 메시지
  - 과거형으로 명명
    - 주문이 발생한다면 다른 Aggregate 에게 "주문되었다" 라는 이벤트를 전달해서 일관성을 맞추게 되기 때문
- Domain Service
  - 여러 개의 Aggregate 를 갖고 비즈니스 로직을 표현할 때 사용

<br>

## 4.5. 이벤트 소싱 패턴

이벤트 자체를 저장해서 특정 시점의 이벤트를 가져올 수 있음

히스토리성, 로깅용 데이터들은 필요

<br>

# 5. MSA 패턴

전술적 설계 (DDD) 는 비즈니스 로직을 모델링하고 구현하는 다양한 방법

시스템은 비즈니스 로직 외에 다양한 기능 (입출력, 저장소, 외부 시스템 연동) 이 필요

이런 구조의 원칙을 제시하기 위해 만든 게 아키텍쳐 패턴

<br>

## 5.1. 레이어드 아키텍쳐 (Layerd)

고전적이고 가장 대중적인 아키텍쳐

"프레젠테이션 - 비즈니스 로직 - 데이터 액세스" 3 계층으로 구성

<br>

## 5.2. 헥사고날 아키텍쳐 (Hexagonal)

port and adapter pattern (포트 앤 어댑터 패턴)

- 외부 영역: 프레젠테이션, 데이터 접근
- 내부 영역: 응용, 비즈니스 로직

외부 영역의 어댑터가 다양하게 변경됨으로 가변성을 수용함

<br>

## 5.3. CQRS

명령 조회 책임 분리 (Command Query Responsibility Segregation)

간단하게 말하면 읽기 (Read) 와 커맨드 (CUD) 모델을 분리함

API 호출에서 가장 많이 사용 되는게 Read 조회 호출

MSA 에서 저장소까지 분리한다면 쓰기 데이터와 읽기 데이터의 동기화가 필요함 (동기식 or 비동기식)

<br>

# 6. MSA 커뮤니케이션 유형

MSA 를 하게 되면 각 바운디드 컨텍스트 별로 데이터, 상태 동기화를 위한 여러 가지 방법이 존재

동기식은 보통 API, 비동기식은 메시지큐를 많이 사용

메시지큐를 사용하는 경우에는 여러 가지 장애 포인트가 더 존재하기 때문에 트랜잭션을 더 신경써줘야 한다

사가 패턴 : 메시지 큐를 통해 통신하는 경우 이벤트 발행/구독 뿐만 아니라 이벤트 성공/실패 또한 서로 주고받으면서 트랜잭션을 보장
