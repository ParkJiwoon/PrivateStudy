- [1. 스프링 부트 웹 애플리케이션 만들기](#1-스프링-부트-웹-애플리케이션-만들기)
  - [스프링 부트의 특징](#스프링-부트의-특징)
  - [리액티브 프로그래밍 (Reactive Programming)](#리액티브-프로그래밍-reactive-programming)
  - [리액티브 스트림 (Reactive Stream)](#리액티브-스트림-reactive-stream)
  - [프로젝트 리액터 (Project Reactor)](#프로젝트-리액터-project-reactor)
- [2. 스프링 부트를 활용한 데이터 액세스](#2-스프링-부트를-활용한-데이터-액세스)
  - [리액티브 프로그래밍의 핵심 요건](#리액티브-프로그래밍의-핵심-요건)
  - [전통적인 반복문 대신 Stream 을 사용하는 이유](#전통적인-반복문-대신-stream-을-사용하는-이유)
  - [Example 쿼리](#example-쿼리)
  - [평문형 연산 (Fluent Operation)](#평문형-연산-fluent-operation)
- [3. 스프링 부트 개발자 도구](#3-스프링-부트-개발자-도구)
  - [3.1. 애플리케이션 시간 단축](#31-애플리케이션-시간-단축)
  - [3.2. 재시작 (Restart)](#32-재시작-restart)
- [4. 스프링 부트 테스트](#4-스프링-부트-테스트)
  - [4.1. 리액티브 단위 테스트 작성](#41-리액티브-단위-테스트-작성)
  - [4.2. 테스트 전략](#42-테스트-전략)
  - [4.3. Slice Test](#43-slice-test)
- [5. 스프링 부트 운영](#5-스프링-부트-운영)
  - [5.1. 로컬에서 JAR 생성 및 배포](#51-로컬에서-jar-생성-및-배포)
  - [5.2. 도커 배포](#52-도커-배포)
- [Referenced](#referenced)

# 1. 스프링 부트 웹 애플리케이션 만들기

## 스프링 부트의 특징

- 신속성 : 애플리케이션을 빠르게 개발하는 데 도움을 줌
- 미리 정의된 방식 : 스프링 부트에 미리 설정해둔 값을 사용할 수 있음
- 이식성 : JDK 가 있는 곳이라면 어디서든 실행 가능
- 실제 서비스 환경에 사용 가능 : 사용하는 곳이 많고 안정적임

## 리액티브 프로그래밍 (Reactive Programming)

- 리액티브 프로그래밍은 생각보다 나온지 오래됨
- 그러나, 과거에는 리액티브 프로그래밍을 사용할 만한 대규모 서비스가 많지 않음
- 클라우드 환경의 보편화로 "문제 있으면 서버 투입하면 됨" 방식이 통하지 않음
- 기존 자원을 더 효율적이고 일관성 있게 사용하는 방법을 찾아서 리액티브 스트림 (Reactive Stream) 등장

## 리액티브 스트림 (Reactive Stream)

- 발행자 (Publisher) 와 구독자 (Subscriber) 사이의 간단한 계약을 정의하는 명세
- 트래픽을 빨리 발행할 수 있지만 구독자가 받을 수 있는 수량을 발행자에게 알려주면서 트래픽 제어 가능 (backpressure)
- 성능이 획기적으로 개선되는 건 아니지만 트래픽을 조절해서 안정적인 사용 가능
- 리액티브 스트림을 개발자가 직접 다루는건 추천하지 않음

## 프로젝트 리액터 (Project Reactor)

- VM ware 에서 만든 리액티브 스트림 구현체
- 논블로킹, 비동기 프로그래밍 모델
- 함수형 프로그래밍 스타일
- 쓰레드를 신경 쓸 필요 없는 동시성

<br>

# 2. 스프링 부트를 활용한 데이터 액세스

## 리액티브 프로그래밍의 핵심 요건

- 리액티브 프로그래밍은 **모든 과정이 리액티브**여야 함
- 웹 컨트롤러, 서비스 계층, 데이터베이스, 셋 중 하나라도 블로킹 방식이면 리액티브는 무너짐
- 리액터를 활용하는 애플리케이션은 많은 수의 쓰레드를 갖고 있지 않기 때문에 한 쓰레드가 막히면 프로그램 전체가 망가짐

<br>

리액티브는 빠르지 않다 (빠르다는 선입견이 많음)

오히려 여러가지 오버헤드 때문에 느리다

데이터가 적은 간단한 애플리케이션에선 오히려 리액티브보다 전통적인 방식이 더 좋을때도 있음

리액티브 패러다임을 지원하는 데이터베이스

- MongoDB
- Redis (Lettuce 만 해당)
- Cassandra
- Elasticsearch
- Neo4j
- Couchbase

대부분 NoSQL 이다.

관계형 DB 를 사용하지 않는 이유는 자바에서 지원하는 RDB 도구들이 블로킹 API 라서

JDBC 나 JPA 를 감싼 후 숨겨진 내부 쓰레드 풀로 리액티브하게 사용할수 있게 해주는 반쪽짜리 솔루션도 있음

그러나 쓰레드는 코어 수만큼 사용하는게 좋고 많을수록 컨텍스트 스위칭 비용만 증가하여 효율이 떨어짐

<br>

## 전통적인 반복문 대신 Stream 을 사용하는 이유

가장 큰 이유는 Side Effect 때문이다.

전통적인 반복문에서는 외부에서 변수에 접근 가능하며 예측 불가능한 값으로 변경할 수 있다.

하지만 Stream 으로 진행되는 플로우는 다른 개발자가 의도치 않은 값으로 변경할 가능성이 없어지기 때문에 안전합니다.

<br>

## Example 쿼리

```java
public interface ItemRepository extends ReactiveCrudRepository<Item, String>, ReactiveQueryByExampleExecutor<Item> {
}

public Flux<Item> searchByExample(String name, String description, boolean useAnd) {
    Item item = new Item(name, description, 0.0);

    // matchingAll 은 조건 모두 일치, matchingAny 은 하나라도 일치
    ExampleMatcher matcher = (useAnd
            ? ExampleMatcher.matchingAll()
            : ExampleMatcher.matchingAny())
                            .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)
                            .withIgnoreCase()
                            .withIgnorePaths("price");

    Example<Item> probe = Example.of(item, matcher);
    return itemRepository.findAll(probe);
}
```

Example 쿼리를 사용하면 조건을 쉽게 추가할 수 있다.

나중에 다른 조건이 추가되어도 쉽게 필터링 가능하다는 장점이 있다.

<br>

## 평문형 연산 (Fluent Operation)

```java
public Flux<Item> searchByFluentExample(String name, String description) {
    return fluentOperations.query(Item.class)
            .matching(query(where("TV tray").is(name).and("Smurf").is(description)))
            .all();
}
```

몽고 DB 쿼리를 보통 문장 형식으로 사용할 수 있는 평문형 연산이 있다.

Operation 클래스를 사용하기 때문에 도메인 별로 각각의 Repository 를 만들 필요가 없다.

<br>

# 3. 스프링 부트 개발자 도구

스프링 부트는 개발자의 편의를 위한 여러가지 도구를 제공합니다.

- 코드를 수정할 때 애플리케이션을 자동으로 재시작 하는 방법
- 브라우저 새로고침을 자동으로 실행하는 라이브 리로드 (LiveReload) 사용법
- 프로젝트 리액터 디버깅 도구

<br>

## 3.1. 애플리케이션 시간 단축

코드를 수정할 때마다 매번 애플리케이션을 재시작 하는 것은 번거로움

기존 스프링
- WAR 파일을 만들고 애플리케이션에 배포해서 재실행
- 무거운 애플리케이션 서버 대신 서블릿 컨테이너를 선택해서 재시작 문제 해결 시도

스프링 부트
- 내장형 서블릿 컨테이너 (embedded servlet container)
- WAR 파일을 만들어서 아파치 톰캣 같은 이미 설치돼 있는 서블릿 컨테이너에 애플리케이션을 배포하는 방식이 아니라, 역으로 애플리케이션에 서블릿 컨테이너를 포함

<br>

**개발자 도구 (DevTools)**

- 애플리케이션 Restart 와 Reload 자동화
- 환경설정 정보 기본값 제공
- 자동설정 (Autoconfiguration) 변경사항 로깅
- 정적 자원 제외
- 라이브 리로드 (LiveReload) 지원

<br>

**의존관계 추가**

```java
developmentOnly 'org.springframework.boot:spring-boot-devtools'
```

<br>

## 3.2. 재시작 (Restart)

IntelliJ 에서는 코드 변경 후 Build > Build Project 를 실행 후 새로고침 하면 변경된 코드가 반영된다.

<br>

# 4. 스프링 부트 테스트

- 리액티브 단위 테스트 작성 방법
- 스프링 부트의 내장 컨테이너 테스트 기능
- 단위 테스트와 통합 테스트의 중간에 위치하는 슬라이스 테스트 (Slice Test) 활용
- 테스트 도구를 활용한 블로킹 코드 검출

<br>

## 4.1. 리액티브 단위 테스트 작성

유닛 테스트
- 테스트 중 가장 단순하고 빠르며 쉬움
- 여기서 말하는 단위 (Unit) 이란 자바에서는 하나의 클래스
- 테스트 대상 클래스가 의존하는 다른 클래스의 실제 인스턴스 대신 가짜 인스턴스 (stub) 을 사용해서 테스트 하는 걸 단위 테스트라고 정의

`spring-boot-starter-test` 에 포함된 테스트 라이브러리
- Spring Boot Test
- JsonPath
- JUnit 5
- AssertJ
- Mockito
- JSONassert
- Spring Test

<br>

## 4.2. 테스트 전략

테스트 코드는 너무 많은 범위를 테스트 할 필요가 없다.

너무 많은 범위를 테스트하려고 하면 나중에 수정이 발생했을때 많은 부분을 고쳐야 하고 이는 관리 비용의 증가로 이어진다.

따라서 다음과 같이 전략을 가져가는 것이 좋다.

- Entity 테스트 : AssertJ 를 활용하여 null 값 처리를 포함한 객체 테스트
- Service 테스트 : StepVerifier 와 Mockito 를 활용한 비즈니스 로직 테스트
- Controller 테스트 : WebTestClient 를 활용하여 API 호출 및 응답 테스트

<br>

## 4.3. Slice Test

위 설명을 보면 단위 테스트 (Entity, Service) 는 DB 를 사용하지 않고 Java 코드 자체만을 테스트 한다.

Repository 를 사용해야 한다면 Mocking 하기 때문에 실제 DB 에 데이터가 들어가는지 확인하기 힘들다.

그렇다고 통합 테스트 (Controller) 는 내장 컨테이너를 실행시키기 때문에 DB 만 테스트하기엔 너무 무겁다.

그래서 스프링 부트에서는 단위 테스트와 통합 테스트의 중간 정도에 해당하는 슬라이스 테스트 (Slice Test) 를 제공한다.

Slice Test Annotation (@DataMongoTest) 을 사용하면 스프링 데이터 몽고디비 관련 기능을 사용할 수 있고 그 외에 @Component 어노테이션이 붙은 다른 빈 정의를 무시한다.

<br>

# 5. 스프링 부트 운영

책에서는 maven 기준으로 되어 있는데 여기서는 gradle 로 정리한다.

<br>

## 5.1. 로컬에서 JAR 생성 및 배포

**5.1.1. 실행 가능한 JAR 파일 생성하는 법**

```sh
# maven
$ ./mvnw package

# gradle
$ ./gradlew build

# 기존껄 지우고 새로 빌드
$ ./gradlew clean build

# 테스트 제외하고 빌드
$ ./gradlew build -x test

# gradle plugin 에서 제공
# 테스트 등 부수적인걸 제외하고 실행 가능한 JAR 파일 생성에만 집중
$ ./gradlew bootJar
```

생성된 JAR 파일은 아직 실행 가능한 파일이 아니라 그저 컴파일된 코드일 뿐임

gradle 로 build 하고 나면 `./build/libs` 에 JAR 파일이 생성됨

만약 libs 디렉토리가 없다면 빌드가 제대로 되지 않은 것

<br>

**5.1.2. JAR 파일 실행**

```sh
$ java -jar ./build/libs/spring-webflux-mongodb-0.0.1-SNAPSHOT.jar 
```

실행하기 위해 필요한 모든 것이 JAR 파일에 담겨 있으므로 JDK 가 설치된 장비라면 어디서든 실행 가능하다

하지만 자바가 설치되어 있지 않은 장비에서는 어떻게 배포할 수 있을까?

<br>

## 5.2. 도커 배포

자바가 설치되어 있지 않은 곳에서는 JAR 파일을 실행할 수 없다.

하지만 도커를 사용하면 컨테이너에 자바와 애플리케이션을 함게 담아서 배포할 수 있다.

```docker
# JDK 이미질르 기반으로 컨테이너 생성
FROM adoptopenjdk/openjdk8:latest

# JAR_FILE 에 JAR 파일 위치 지정
ARG JAR_FILE=build/libs/*.jar

# JAR 파일을 app.jar 파일로 복사
COPY ${JAR_FILE} app.jar

# java -jar /app.jar 명령어 실행
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

<br>

**5.2.1. 도커의 캐시 시스템**

도커는 컨테이너 빌드에 소요되는 시간을 줄이기 위해 **계층화 (layering)** 을 이용한다.

계층화란 Dockerfile 의 여러 부분을 각각 하나의 계층으로 만들어서, 해당 계층에 변경이 발생하면 그 계층만 새로 빌드하는 방식이다.

만약 스프링 부트 및 모든 라이브러리를 한 계층에 담으면, 변경사항이 생길 때 매번 전부 다 빌드해야 한다.

다행히 maven 과 gradle 모두 도커 계층화를 지원하고 [gradle 은 기본값으로 세팅](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootJar.html#layered--)되어 있다.

만약 layered 옵션을 끄려면 다음과 같이 `build.gradle` 에 추가하면 된다.

```groovy
bootJar {
  layered {
    enabled = false
  }
}
```

계층은 다음 명령어로 확인할 수 있다.

```sh
$ java -Djarmode=layertools -jar build/libs/spring-webflux-mongodb-0.0.1-SNAPSHOT.jar list

dependencies
spring-boot-loader
snapshot-dependencies
application
```

<br>

계층화를 적용해서 다시 Dockerfile 을 작성해본다.

```docker
# 빌더로 사용할 컨테이너 생성
FROM adoptopenjdk/openjdk11:latest as builder
WORKDIR application
ARG JAR_FILE=build/libs/*.jar
COPY ${JAR_FILE} application.jar

# extract 명령어로 layer 추출
RUN java -Djarmode=layertools -jar application.jar extract

# 두번째 컨테이너 생성
FROM adoptopenjdk/openjdk11:latest
WORKDIR application

# 빌더 컨테이너에서 추출한 여러 레이러를 두번째 컨테이너에 복사
# COPY 명령은 도커의 계층 캐시 알고리즘이 적용돼서 최소한의 변화만 반영됨
COPY --from=builder application/dependencies/ ./
COPY --from=builder application/spring-boot-loader/ ./
#COPY --from=builder application/snapshot-dependencies/ ./
COPY --from=builder application/application/ ./

# java -jar 대신 스프링 부트의 커스텀 런처 (custom launcher) 로 애플리케이션 실행
# 이 런처는 애플리케이션 시작 시 불필요한 JAR 파일 압축 해제를 하지 않으므로 효율적
ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
```

애플리케이션에서 사용하는 의존 라이브러리 버전에 따라 특정 계층이 만들어지지 않을 수도 있다.

예를 들어, 스냅샷 (snapshot) 의존관계가 없어 해당 계층이 만들어지지 않으면 위 코드처럼 주석 처리가 가능하다.

<br>

**5.2.2. 도커 컨테이너 이미지 빌드**

```sh
$ docker build . --tag spring-webflux-mongodb
```

위 명령어로 이미지를 빌드한 후에 코드를 수정하고 다시 빌드하면 application 계층 외의 나머지 계층은 캐시를 사용한다.

<br>

**5.2.3. 도커로 애플리케이션 실행**

```sh
$ docker run -it -p 8080:8080 spring-webflux-mongodb:latest
```

<br>

**5.2.4. Dockerfile 없이 도커 컨테이너 이미지 빌드 기능**

Spring Boot 2.3 부터 Dockerfile 없이 도커 컨테이너 이미지를 만드는 기능을 지원한다.

Gradle 은 [bootBuildImage](https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/gradle-plugin/reference/html/#build-image) 라는 명령어로 사용 가능하고 Maven 은 `./mvnw spring-boot:build-image` 명령어를 사용한다.

```sh
# build 초기화 후 docker image 생성
$ ./gradlew clean bootBuildImage

# 만들어진 docker image 실행
$ docker run -it -p 8080:8080 spring-webflux-mongodb:0.0.1-SNAPSHOT  
```



<br>

# Referenced

- https://github.com/onlybooks/spring-boot-reactive